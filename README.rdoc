= Usher 

Tree-based router for Ruby on Rails.

This is a tree-based router (based on Ilya Grigorik suggestion). Turns out looking up in a hash and following a tree is faster than Krauter's massive regex approach, so why not? I said, Heck Yes, and here we are.

== Route format

From the rdoc:

<tt>+path+</tt>::
   A path consists a mix of dynamic and static parts delimited by <tt>/</tt>

   *Dynamic*

   Dynamic parts are prefixed with either :, *.  :variable matches only one part of the path, whereas *variable can match one or
   more parts. 

   Example:
   <tt>/path/:variable/path</tt> would match
   
   * <tt>/path/test/path</tt>
   * <tt>/path/something_else/path</tt>
   * <tt>/path/one_more/path</tt>
   
   In the above examples, 'test', 'something_else' and 'one_more' respectively would be bound to the key <tt>:variable</tt>.
   However, <tt>/path/test/one_more/path</tt> would not be matched. 
   
   Example:
   <tt>/path/*variable/path</tt> would match
   
   * <tt>/path/one/two/three/path</tt>
   * <tt>/path/four/five/path</tt>
   
   In the above examples, ['one', 'two', 'three'] and ['four', 'five'] respectively would be bound to the key :variable.

   *Static*
   
   Static parts of literal character sequences. For instance, <tt>/path/something.html</tt> would match only the same path.

   <b>Optional sections</b>

   Sections of a route can be marked as optional by surrounding it with brackets. For instance, in the above static example, <tt>/path/something(.html)</tt> would match both <tt>/path/something</tt> and <tt>/path/something.html</tt>.

<tt>+options+</tt>::
   --
   * :transformers - Transforms a variable before it gets to the conditions and requirements. Takes either a +proc+ or a +symbol+. If its a +symbol+, calls the method on the incoming parameter. If its a +proc+, its called with the variable.
   * :requirements - After transformation, tests the condition using ===. If it returns false, it raises an <tt>Usher::ValidationException</tt>
   * :conditions - Accepts any of the following <tt>:protocol</tt>, <tt>:domain</tt>, <tt>:port</tt>, <tt>:query_string</tt>, <tt>:remote_ip</tt>, <tt>:user_agent</tt>, <tt>:referer</tt> and <tt>:method</tt>. This can be either a <tt>string</tt> or a <tt>regexp</tt>.
   * any other key is interpreted as a requirement for the variable of its name.

== Rails

  script/plugin install git://github.com/joshbuddy/usher.git

== Rack

=== rackup.ru

  require 'usher'
  app = proc do |env|
    body = "Hi there #{env['usher.params'][:name]}"
    [
      200,          # Status code
      {             # Response headers
        'Content-Type' => 'text/plain',
        'Content-Length' => body.size.to_s,
      },
      [body]        # Response body
    ]
  end
  
  routes = Usher::Interface.for(:rack)
  routes.add('/hello/:name').to(app)
  run routes

------------

  >> curl http://127.0.0.1:3000/hello/samueltanders
  << Hi there samueltanders

== DONE

* add support for () optional parts
* Add support for arbitrary HTTP header checks

== TODO

* Make it integrate with merb
* Make it integrate with rails3
* Create decent DSL for use with rack
* Emit exceptions inline with relevant interfaces
* More RDoc! (optionally cowbell)

Looks about 20-50% faster than the router Rails ships with for non-trivial cases.

(Let me show you to your request)
